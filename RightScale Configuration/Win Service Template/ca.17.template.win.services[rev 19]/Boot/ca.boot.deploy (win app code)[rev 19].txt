# Powershell 2.0
# Copyright (c) 2008-2013 RightScale, Inc, All Rights Reserved Worldwide.

$errorActionPreference = "Stop"
 
$CA_REBOOT = [environment]::GetEnvironmentVariable("CA_REBOOT","Machine")

# Add $env: to force execute input if this code is ever uncommented
if ([System.Convert]::ToBoolean($CA_REBOOT) -and !([System.Convert]::ToBoolean($env:CA_GLB_FORCE_EXECUTE))){
          
  write-host "Skipping after reboot."
  exit 0
}

$caPSLibPath = $env:CA_GBL_RS_LIB_FILE_PATH
$downloadPath = $env:CA_GBL_DOWNLOAD_FOLDER_PATH
$releaseFileS3Key = $env:CA_SA_RELEASE_FILE_S3_KEY
$bucketName = $env:CA_GBL_OPS_BUCKET_NAME
$region = $env:CA_DPL_REGION
$logLevel = $env:CA_GBL_LOGGING_LEVEL
$blnEncryptConfig = $env:CA_SA_BOOL_ENCRYPT_CONFIG
$xmlKeys = $env:CA_DPL_CONFIG_ENCRYPTION_KEY
$blnStartService =$env:CA_SA_BOOL_START_SERVICE
$tierName = $env:CA_SA_TIER_NAME

#Initialize the variables with the credentials which contains the data for external config files and the corresponding external config file name
$connStringsXML = $env:CA_SA_CRED_CONFIG_CONNSTRINGS
$connStringsFileName = "connstrings.config"

$winservicesAppSettingsXML = $env:CA_SA_CRED_CONFIG_APPSETTINGS
$winservicesAppSettingsFileName = "ca-appsettings.config"


#Create a hashtable using the external config file name as the key and file contents coming from credentials as the value
$tblExternalConfig = @{"submission"=@{$winservicesAppSettingsFileName=$winservicesAppSettingsXML;$connStringsFileName=$connStringsXML};
                       "swflargemember"=@{$winservicesAppSettingsFileName=$winservicesAppSettingsXML;$connStringsFileName=$connStringsXML};
                       "swfsmallmember"=@{$winservicesAppSettingsFileName=$winservicesAppSettingsXML;$connStringsFileName=$connStringsXML};
                       "swflargesds"=@{$winservicesAppSettingsFileName=$winservicesAppSettingsXML;$connStringsFileName=$connStringsXML};
                       "accountrollover"=@{$winservicesAppSettingsFileName=$winservicesAppSettingsXML;$connStringsFileName=$connStringsXML}
                       }


#Following variables can contain one more values separated by coma
$arrWinServiceName = $env:CA_SA_ARR_WIN_SERVICE_NAME.split(",")
$arrInstallFolderPath = $env:CA_SA_ARR_INSTALL_FOLDER_PATH.split(",")
$arrExeFileName = $env:CA_SA_ARR_EXE_FILE_NAME.split(",")
$arrBuildSrcFolderPath = $env:CA_SA_ARR_BUILD_SOURCE_FOLDER_PATH.split(",")
$arrConfigFileS3Key = $env:CA_SA_ARR_CONFIG_FILE_S3_KEY.split(",")
$arrAdditionalConfigFileS3Key = $env:CA_SA_ARR_ADD_CONFIG_FILE_S3_KEY.split(",")


$tblInstallFolderPath = @{}
$tblExeFileName = @{}
$tblBuildSrcFolderPath = @{}
$tblConfigFileS3Key = @{}

# Create hashtables using array containing service properties like installation folder, executable file name and build source folder in the build package
$arrWinServiceName | % {$i=0}{$tblInstallFolderPath.Add($_, $($arrInstallFolderPath[$i]));$i++}
$arrWinServiceName | % {$i=0}{$tblExeFileName.Add($_, $($arrExeFileName[$i]));$i++}
$arrWinServiceName | % {$i=0}{$tblBuildSrcFolderPath.Add($_, $($arrBuildSrcFolderPath[$i]));$i++}
$arrWinServiceName | % {$i=0}{$tblConfigFileS3Key.Add($_, $($arrConfigFileS3Key[$i]));$i++}

# include the CA powershell library
. $caPSLibPath

#Import-Module -Name "C:\Program Files (x86)\AWS Tools\PowerShell\AWSPowerShell\AWSPowerShell.psd1"


try{

  # Create download folder if it doesn't exist
  if ( -not (Test-Path $downloadPath)) {
    mkdir $downloadPath
  }

  Remove-Item (Join-Path $downloadPath "*") -recurse -force

  #Download the release package from S3
  $releaseFileName = GetS3File $region $bucketName $releaseFileS3Key $downloadPath

  #Unzip the file in the downloaded folder
  UnzipFile $downloadPath $releaseFileName

  #Stop the services if already exists
  foreach ($winServiceName in $arrWinServiceName) {
    
    "Starting installation of service $winServiceName."
        
    #Stop the service before updating the code
    if (Get-Service $winServiceName -ErrorAction SilentlyContinue){
    
      Stop-Service $winServiceName
            
      "Service status of $winServiceName is $(Get-Service $winServiceName | % {$_.status})." 
    }else {
      Write-Host "Service $winServiceName does not exits"
      $Error.Clear()
    }
    
    #get installation information for the service
    $installFolderPath = $tblInstallFolderPath.Get_Item($winServiceName)
    $buildSrcFolderPath = Join-Path (Join-Path $downloadPath $tblBuildSrcFolderPath.Get_Item($winServiceName)) "*"
    $configFileS3Key = $tblConfigFileS3Key.Get_Item($winServiceName)
    $exeFileName = "$($tblExeFileName.Get_Item($winServiceName)).exe"
    
    #Create an array for all config files needed for a service, including service.exe.config and any additional channel config files
    $arrServiceConfigFileS3Key = $arrAdditionalConfigFileS3Key
    $arrServiceConfigFileS3Key += $configFileS3Key
        
    if ( -not (Test-Path $installFolderPath)) {
      mkdir $installFolderPath
    }

    #Remove-Item (Join-Path $installFolderPath "*") -recurse -force
    CleanupFolder (Join-Path $installFolderPath "*") 60
        
    Copy-Item $buildSrcFolderPath -Destination $installFolderPath -recurse

    DeployConfigFile $region $bucketName $arrServiceConfigFileS3Key $installFolderPath $tierName $tblExternalConfig
        
    if ($blnEncryptConfig.ToLower() -eq "true"){
      EncryptTierConfigFiles $installFolderPath $tierName $tblExternalConfig
    }
 
    $logFilePath = Join-Path $installFolderPath "logging.config"

    SetLoggingLevel $logFilePath $logLevel

    #Install the service and set the recovery options if service doesn't already exits
    if (-not (Get-Service $winServiceName -ErrorAction SilentlyContinue)){
            
      Write-Host "Installing service $winServiceName."
      ExecuteCommand """$(Join-Path $installFolderPath $exeFileName)"" install" "Unable to install the windows service $winServiceName."
      
      #set starttype to "Automaic"
      set-service -name $winServiceName -startuptype automatic;
            
      #set recovery to 1 minute and reset count after 0 day
      sc.exe failure $winServiceName reset= 0 actions= restart/60000;
    }
    
    #If start service flag is true then start the service after installation or code update
    #if ($blnStartService.ToLower() -eq "true"){
    #  "Starting the service $winServiceName"
      
    #  StartService $winServiceName 120
      
    #}else {
    #  "Service not started as Start Service flag is false"
    #}
        
    "Installation of service $winServiceName completed successfully."
  }
    
    "Windows services code deployment completed successfully."
}
catch{
    "There is an error: $_"
    "Windows services code deployment failed."
    
    exit 1
}
